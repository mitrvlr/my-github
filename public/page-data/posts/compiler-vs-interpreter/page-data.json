{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/compiler-vs-interpreter","webpackCompilationHash":"","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Compiler vs Interpreter","path":"/posts/compiler-vs-interpreter","tags":["front-end"],"date":"July 18, 2016"},"html":"<p><img src=\"https://cloud.githubusercontent.com/assets/24470477/23200135/064adfc8-f916-11e6-9894-200a5ea5c587.jpg\" alt=\"o5xjh\"></p>\n<h3>컴파일러</h3>\n<ul>\n<li>특정 프로그래밍 언어로 작성한 소소코드를 다른 프로그래밍 언어로 변환하는 프로그램</li>\n<li>주로 원시 소스코드를 어셈블리어나 기계어로 변환한다. </li>\n<li>직접 기계어로 변환하면 부담이 크기 때문에 어셈블리형식의 목적 파일로 생성하는 경우가 많다.</li>\n</ul>\n<h3>인터프리터</h3>\n<ul>\n<li>\n<p>컴파일러 + 인터프리터 결합형</p>\n<ul>\n<li>소스코드를 중간 코드 형태로 변환 후 인터프리터가 읽어드려 메모리에 적재하고 해석하며 실행한다. </li>\n<li>ex) Java code (.java) > JVM : bytecode (.class)</li>\n</ul>\n</li>\n<li>\n<p>소스코드 유지형 : 소스코드를 그대로 메모리에 유지한채 라인 단위로 해석해서 실행 (성능향상을 위해 실행 시점에 원시코드나 중간 코드를 네이티브 코드로 변환) </p>\n<ul>\n<li>소스코드</li>\n<li>어휘 분석</li>\n<li>내부코드 생성</li>\n<li>\n<p>구문 분석 실행</p>\n<ul>\n<li>분석한 토큰열이 구문과 일치한가 확인</li>\n<li>토글이 변수/함수 정의일때 심볼테이블에 등록한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>JIT Compile</h3>\n<p>실제 실행 시점에 기계어로 변환하는 컴파일러</p>\n<ul>\n<li>Method JIT : 메소드 단위로 프로그램을 실행할 때마다 기계어로 변환</li>\n<li>tracing JIT : 자주 실행하는 부분만 기계어로 변환</li>\n</ul>\n<h4>Reference</h4>\n<p><a href=\"http://huns.me/development/360\">[기계어(Machine code)와 어셈블리어(Assembly)]</a></p>"}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}