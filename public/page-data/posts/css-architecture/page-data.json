{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/css-architecture","webpackCompilationHash":"","result":{"data":{"markdownRemark":{"frontmatter":{"title":"about CSS Architecture","path":"/posts/css-architecture","tags":["front-end","css"],"date":"January 08, 2016"},"html":"<p><img src=\"https://cloud.githubusercontent.com/assets/24470477/23197921/008b44ce-f907-11e6-81b5-1a69131fc1e9.png\" alt=\"book-covers\">\n{:.tac}</p>\n<h3>* SMACSS <em>(Scalable &#x26; Modular Architecture for CSS)</em></h3>\n<p>SMACSS는 CSS를 5가지로 분류/범주화하여 작명규칙 등 스타일 가이드를 제시한 방법론이다.</p>\n<ul>\n<li><em>Bass</em> : 기본스타일(Reset, Default, Variables, Mixins) 등 ID, class 셀렉터의 정의 없이 기본 스타일 구축</li>\n<li>\n<p><em>Layout</em> </p>\n<ul>\n<li>페이지 분할 요소 스타일 구축</li>\n<li>l- ,layout-, grid- 등의 접두사(prefix)를 사용하여 클래스 명을 접미사(suffix)로 조합하여 구축</li>\n</ul>\n</li>\n<li>\n<p><em>Module</em> </p>\n<ul>\n<li>스타일 반복, 재사용을 위한 요소 스타일 구축</li>\n<li>위치기반의 클래스명 작명은 지양한다.</li>\n</ul>\n</li>\n<li>\n<p><em>State</em></p>\n<ul>\n<li>상태를 나타내는 요소 스타일 구축</li>\n<li>is-, s- 등의 접두사(prefix)를 사용하여 클래스 명을 접미사(suffix)로 조합하여 구축</li>\n<li>자바스크립트에 의존적인 요소 스타일 / Layout, Module에 사용이 가능한 요소 스타일</li>\n</ul>\n</li>\n<li><em>Theme</em> : 사이트의 전반적 look and feel 제어</li>\n</ul>\n<hr>\n<h3>* OOCSS <em>(Object Oriented CSS)</em></h3>\n<p>OOCSS는 2가지 범주 내에서 독립적인 요소로 추상화할 수 있는 반복패턴을 정의하여 사용하자는 객체 지향 스타일 가이드를 제시한 방법론이다.</p>\n<ul>\n<li>표현과 구조의 분리 <em>(Separate structure and skin)</em> : CSS를 Positioning / Styling으로 객체화하여 Mix &#x26; Match </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">  <span class=\"token selector\">.position</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> relative<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">display</span><span class=\"token punctuation\">:</span> block<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">float</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token selector\">.style</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> transparent<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>컨테이너와 콘텐츠의 분리 <em>(Separate container and content)</em> : DOM 위치에 의존하지 않고 객체의 재사용이 가능한 클래스 기반 모듈 구축</li>\n<li><em>장점</em> : 코드의 재사용성이 높아진다.</li>\n<li>\n<p><em>단점</em></p>\n<ul>\n<li>다중클래스를 사용하여 HTML이 복잡해진다.</li>\n<li>의미 있는 클래스 이름을 짓기 어렵다.</li>\n</ul>\n</li>\n</ul>\n<h4>* OOSass</h4>\n<p>OOCSS를 토대로 Sass에 적용하는 방법론<br>\n(Less, Sass와 같은 CSS 전처리기를 사용하여 OOCSS의 단점을 보완하고 Mixin을 사용하여 코드의 재활용성과 의미 있는 네이밍 등의 장점을 극대화하여 사용할수 있다.)</p>\n<hr>\n<h3>* BEM (Block Element Modifier)</h3>\n<ul>\n<li><em>Block</em> : 문단 전체에 적용된 엘리먼트, 또는 엘리먼트를 담고 있는 컨테이너를 말함</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">  <span class=\"token selector\">.block-name</span> <span class=\"token punctuation\">{</span>\n    //\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><em>Element</em> : Block 안에서 특정기능을 수행하는 컴포넌트</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">  <span class=\"token selector\">.block-name__element-name</span><span class=\"token punctuation\">{</span>\n    //\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><em>Modifier</em> : Block, Element의 외관/상태를 변화시킨다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\">  <span class=\"token selector\">.block-name__element-name--modifier</span> <span class=\"token punctuation\">{</span>\n    //\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><em>장점</em> : 의미있는 클래스 이름의 작명이 가능하다.</li>\n<li><em>단점</em> : 클래스 이름이 길어진다.</li>\n</ul>\n<h4>BEM 방법론을 토대로 응용한 사례</h4>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">.module-function-expand</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token selector\">//\n\t&amp;.statement</span> <span class=\"token punctuation\">{</span>\n\t\t//\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><em>* 여러 방법론을 토대로 사용하기 쉽고 효율적으로 자신만의 방법론으로 사용함을 추천한다.</em></p>\n<h4>Reference</h4>\n<ul>\n<li><a href=\"http://itzone.tistory.com/569\">[CSS 구조 개선 방법론]</a></li>\n<li><a href=\"http://wit.nts-corp.com/2015/04/16/3538\">[CSS방법론: SMACSS, BEM, OOCSS]</a></li>\n<li><a href=\"http://mytory.net/archives/8986\">[[번역] OOCSS(객체 지향 CSS)와 Sass를 결합하는 것이 최고의 CSS 코딩 방법이다(OOCSS + Sass = The best way to CSS)]</a></li>\n</ul>"}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}